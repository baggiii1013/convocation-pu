name: Deploy to Production

on:
  push:
    branches:
      - master
  workflow_dispatch:  # Allow manual triggers
    inputs:
      skip_tests:
        description: 'Skip build and test step'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deploy even if health check fails'
        required: false
        default: false
        type: boolean

# Cancel in-progress deployments when a new one starts
concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  NODE_ENV: production
  DEPLOY_PATH: /home/appadmin/convocation-pu
  BACKUP_PATH: /home/appadmin/backups

jobs:
  # ===========================================
  # JOB 1: BUILD AND TEST
  # ===========================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üçû Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: üì¶ Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
            apps/*/node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: üì¶ Install Dependencies
        run: bun install --frozen-lockfile

      - name: üîç Type Check API
        working-directory: ./apps/api
        run: bun run type-check
        continue-on-error: true

      - name: üîç Lint Web
        working-directory: ./apps/web
        run: bun run lint
        continue-on-error: true

      - name: üî® Build API
        working-directory: ./apps/api
        run: bun run build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: üî® Build Web
        working-directory: ./apps/web
        run: bun run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}

      - name: ‚úÖ Build Successful
        run: echo "Build completed successfully!"

  # ===========================================
  # JOB 2: DEPLOY TO SERVER (ZERO DOWNTIME)
  # ===========================================
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build-and-test
    if: |
      always() && 
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped') &&
      github.ref == 'refs/heads/master'
    environment: production
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîë Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Acquire Deployment Lock
        id: lock
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            LOCK_FILE="/tmp/deploy.lock"
            
            # Check if lock exists and is recent (within 30 minutes)
            if [ -f "$LOCK_FILE" ]; then
              LOCK_AGE=$(($(date +%s) - $(stat -c %Y "$LOCK_FILE")))
              if [ $LOCK_AGE -lt 1800 ]; then
                echo "‚ùå Another deployment is in progress. Lock age: ${LOCK_AGE}s"
                exit 1
              else
                echo "‚ö†Ô∏è Stale lock found (${LOCK_AGE}s old). Removing..."
                rm -f "$LOCK_FILE"
              fi
            fi
            
            # Create lock
            echo "${{ github.run_id }}" > "$LOCK_FILE"
            echo "‚úÖ Deployment lock acquired"
          ENDSSH

      - name: üíæ Create Pre-Deployment Backup
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            
            BACKUP_DIR="${{ env.BACKUP_PATH }}/$(date +%Y%m%d_%H%M%S)_${{ github.sha }}"
            mkdir -p "$BACKUP_DIR"
            
            echo "üíæ Creating backup at $BACKUP_DIR..."
            
            # Backup built artifacts
            if [ -d "${{ env.DEPLOY_PATH }}/apps/api/dist" ]; then
              cp -r "${{ env.DEPLOY_PATH }}/apps/api/dist" "$BACKUP_DIR/api-dist"
            fi
            
            if [ -d "${{ env.DEPLOY_PATH }}/apps/web/.next" ]; then
              cp -r "${{ env.DEPLOY_PATH }}/apps/web/.next" "$BACKUP_DIR/web-next"
            fi
            
            # Save current commit hash
            cd "${{ env.DEPLOY_PATH }}"
            git rev-parse HEAD > "$BACKUP_DIR/commit_hash"
            
            # Store backup path for potential rollback
            echo "$BACKUP_DIR" > /tmp/last_backup_path
            
            # Clean old backups (keep last 5)
            cd "${{ env.BACKUP_PATH }}"
            ls -dt */ | tail -n +6 | xargs -r rm -rf
            
            echo "‚úÖ Backup created successfully"
          ENDSSH

      - name: üîê Sync Environment Files
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << ENDSSH
            echo "üîê Syncing API environment file..."
            cat > ${{ env.DEPLOY_PATH }}/apps/api/.env << 'ENVEOF'
          ${{ secrets.API_ENV_FILE }}
          ENVEOF
            echo "‚úì API .env synced"
            
            echo "üîê Syncing Web environment file..."
            cat > ${{ env.DEPLOY_PATH }}/apps/web/.env.production << 'ENVEOF'
          ${{ secrets.WEB_ENV_FILE }}
          ENVEOF
            echo "‚úì Web .env.production synced"
          ENDSSH

      - name: üöÄ Deploy to Server (Zero Downtime)
        id: deploy
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            
            echo "=========================================="
            echo "üöÄ Starting Zero-Downtime Deployment"
            echo "=========================================="
            
            cd ${{ env.DEPLOY_PATH }}
            
            # Save current commit for rollback reference
            PREVIOUS_COMMIT=$(git rev-parse HEAD)
            echo "üìå Previous commit: $PREVIOUS_COMMIT"
            
            echo ""
            echo "üì• Step 1: Pulling latest changes..."
            git fetch origin master
            git reset --hard origin/master
            NEW_COMMIT=$(git rev-parse HEAD)
            echo "‚úÖ Updated to commit: $NEW_COMMIT"
            
            echo ""
            echo "üì¶ Step 2: Installing dependencies..."
            /home/appadmin/.bun/bin/bun install --frozen-lockfile
            echo "‚úÖ Dependencies installed"
            
            echo ""
            echo "üî® Step 3: Building API..."
            cd apps/api
            /home/appadmin/.bun/bin/bun run build
            cd ../..
            echo "‚úÖ API built"
            
            echo ""
            echo "üî® Step 4: Building Web..."
            cd apps/web
            /home/appadmin/.bun/bin/bun run build
            cd ../..
            echo "‚úÖ Web built"
            
            echo ""
            echo "üîÑ Step 5: Performing rolling restart..."
            
            # PM2 reload does rolling restart (one instance at a time)
            # This ensures zero downtime as new instances start before old ones stop
            pm2 reload ecosystem.config.cjs --update-env
            
            echo ""
            echo "‚è≥ Step 6: Waiting for applications to stabilize..."
            sleep 10
            
            # Check if processes are running
            echo ""
            echo "üìä PM2 Status:"
            pm2 status
            
            # Verify processes are online
            API_STATUS=$(pm2 jlist | jq -r '.[] | select(.name == "convocation-api") | .pm2_env.status')
            WEB_STATUS=$(pm2 jlist | jq -r '.[] | select(.name == "convocation-web") | .pm2_env.status')
            
            if [ "$API_STATUS" != "online" ] || [ "$WEB_STATUS" != "online" ]; then
              echo "‚ùå One or more services failed to start!"
              echo "API Status: $API_STATUS"
              echo "Web Status: $WEB_STATUS"
              exit 1
            fi
            
            echo ""
            echo "=========================================="
            echo "üéâ Deployment completed successfully!"
            echo "=========================================="
          ENDSSH

      - name: üè• Health Check (with retries)
        id: health_check
        run: |
          echo "Waiting for services to be fully ready..."
          sleep 10
          
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check API health
            API_HEALTH=$(curl -sf "http://${{ secrets.SERVER_HOST }}:3001/health" || echo "failed")
            
            # Check Web health (homepage loads)
            WEB_HEALTH=$(curl -sf -o /dev/null -w "%{http_code}" "https://${{ secrets.SERVER_HOST }}/" || echo "000")
            
            echo "API Health: $API_HEALTH"
            echo "Web Health: $WEB_HEALTH"
            
            if [ "$API_HEALTH" != "failed" ] && [ "$WEB_HEALTH" = "200" ]; then
              echo "‚úÖ All health checks passed!"
              exit 0
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          echo "‚ùå Health checks failed after $MAX_RETRIES attempts"
          exit 1
        continue-on-error: ${{ github.event.inputs.force_deploy == 'true' }}

      - name: üîô Rollback on Failure
        if: failure() && steps.deploy.outcome == 'success' && steps.health_check.outcome == 'failure' && github.event.inputs.force_deploy != 'true'
        run: |
          echo "üîô Initiating rollback due to failed health checks..."
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            
            BACKUP_DIR=$(cat /tmp/last_backup_path 2>/dev/null || echo "")
            
            if [ -z "$BACKUP_DIR" ] || [ ! -d "$BACKUP_DIR" ]; then
              echo "‚ùå No backup found for rollback!"
              exit 1
            fi
            
            echo "üîô Rolling back to backup: $BACKUP_DIR"
            
            cd ${{ env.DEPLOY_PATH }}
            
            # Restore previous commit
            if [ -f "$BACKUP_DIR/commit_hash" ]; then
              PREV_COMMIT=$(cat "$BACKUP_DIR/commit_hash")
              echo "Resetting to commit: $PREV_COMMIT"
              git reset --hard "$PREV_COMMIT"
            fi
            
            # Restore built artifacts
            if [ -d "$BACKUP_DIR/api-dist" ]; then
              rm -rf apps/api/dist
              cp -r "$BACKUP_DIR/api-dist" apps/api/dist
            fi
            
            if [ -d "$BACKUP_DIR/web-next" ]; then
              rm -rf apps/web/.next
              cp -r "$BACKUP_DIR/web-next" apps/web/.next
            fi
            
            # Reload PM2 with rolled back code
            pm2 reload ecosystem.config.cjs --update-env
            
            echo "‚úÖ Rollback completed!"
            pm2 status
          ENDSSH

      - name: üîì Release Deployment Lock
        if: always()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            rm -f /tmp/deploy.lock
            echo "üîì Deployment lock released"
          ENDSSH

      - name: üìù Deployment Summary
        if: success()
        run: |
          echo "## üéâ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # JOB 3: NOTIFY ON FAILURE
  # ===========================================
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy]
    if: failure()
    
    steps:
      - name: üö® Deployment Failed
        run: |
          echo "## ‚ùå Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          
          # Add your notification logic here (Slack, Discord, Email, etc.)
          # Example for Discord webhook:
          # curl -H "Content-Type: application/json" \
          #   -d '{"content": "üö® Deployment failed for convocation-pu!"}' \
          #   ${{ secrets.DISCORD_WEBHOOK_URL }}
