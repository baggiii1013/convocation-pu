name: Deploy to Production

on:
  push:
    branches:
      - master
  workflow_dispatch:  # Allow manual triggers
    inputs:
      skip_tests:
        description: 'Skip build and test step'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deploy even if health check fails'
        required: false
        default: false
        type: boolean

# Cancel in-progress deployments when a new one starts
concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  NODE_ENV: production
  DEPLOY_PATH: /home/appadmin/convocation-pu
  BACKUP_PATH: /home/appadmin/backups

jobs:
  # ===========================================
  # JOB 1: BUILD AND TEST (runs on GitHub servers)
  # ===========================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸž Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: ðŸ“¦ Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
            apps/*/node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: ðŸ“¦ Install Dependencies
        run: bun install --frozen-lockfile

      - name: ðŸ” Type Check API
        working-directory: ./apps/api
        run: bun run type-check
        continue-on-error: true

      - name: ðŸ” Lint Web
        working-directory: ./apps/web
        run: bun run lint
        continue-on-error: true

      - name: ðŸ”¨ Build API
        working-directory: ./apps/api
        run: bun run build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: ðŸ”¨ Build Web
        working-directory: ./apps/web
        run: bun run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}

      - name: âœ… Build Successful
        run: echo "Build completed successfully!"

  # ===========================================
  # JOB 2: DEPLOY TO SERVER (runs on self-hosted runner)
  # ===========================================
  deploy:
    name: Deploy to Production Server
    runs-on: [self-hosted, linux, convocation]
    needs: build-and-test
    if: |
      always() && 
      (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped') &&
      github.ref == 'refs/heads/master'
    
    steps:
      - name: ðŸ”’ Acquire Deployment Lock
        id: lock
        run: |
          LOCK_FILE="/tmp/deploy.lock"
          
          # Check if lock exists and is recent (within 30 minutes)
          if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(($(date +%s) - $(stat -c %Y "$LOCK_FILE")))
            if [ $LOCK_AGE -lt 1800 ]; then
              echo "âŒ Another deployment is in progress. Lock age: ${LOCK_AGE}s"
              exit 1
            else
              echo "âš ï¸ Stale lock found (${LOCK_AGE}s old). Removing..."
              rm -f "$LOCK_FILE"
            fi
          fi
          
          # Create lock
          echo "${{ github.run_id }}" > "$LOCK_FILE"
          echo "âœ… Deployment lock acquired"

      - name: ðŸ’¾ Create Pre-Deployment Backup
        run: |
          set -e
          
          BACKUP_DIR="${{ env.BACKUP_PATH }}/$(date +%Y%m%d_%H%M%S)_${{ github.sha }}"
          mkdir -p "$BACKUP_DIR"
          
          echo "ðŸ’¾ Creating backup at $BACKUP_DIR..."
          
          # Backup built artifacts
          if [ -d "${{ env.DEPLOY_PATH }}/apps/api/dist" ]; then
            cp -r "${{ env.DEPLOY_PATH }}/apps/api/dist" "$BACKUP_DIR/api-dist"
          fi
          
          if [ -d "${{ env.DEPLOY_PATH }}/apps/web/.next" ]; then
            cp -r "${{ env.DEPLOY_PATH }}/apps/web/.next" "$BACKUP_DIR/web-next"
          fi
          
          # Save current commit hash
          cd "${{ env.DEPLOY_PATH }}"
          git rev-parse HEAD > "$BACKUP_DIR/commit_hash"
          
          # Store backup path for potential rollback
          echo "$BACKUP_DIR" > /tmp/last_backup_path
          
          # Clean old backups (keep last 5)
          cd "${{ env.BACKUP_PATH }}"
          ls -dt */ 2>/dev/null | tail -n +6 | xargs -r rm -rf || true
          
          echo "âœ… Backup created successfully"

      - name: ðŸ” Sync Environment Files
        run: |
          echo "ðŸ” Syncing API environment file..."
          cat > ${{ env.DEPLOY_PATH }}/apps/api/.env << 'ENVEOF'
          ${{ secrets.API_ENV_FILE }}
          ENVEOF
          echo "âœ“ API .env synced"
          
          echo "ðŸ” Syncing Web environment file..."
          cat > ${{ env.DEPLOY_PATH }}/apps/web/.env.production << 'ENVEOF'
          ${{ secrets.WEB_ENV_FILE }}
          ENVEOF
          echo "âœ“ Web .env.production synced"

      - name: ðŸš€ Deploy (Zero Downtime)
        id: deploy
        run: |
          set -e
          
          echo "=========================================="
          echo "ðŸš€ Starting Zero-Downtime Deployment"
          echo "=========================================="
          
          cd ${{ env.DEPLOY_PATH }}
          
          # Save current commit for rollback reference
          PREVIOUS_COMMIT=$(git rev-parse HEAD)
          echo "ðŸ“Œ Previous commit: $PREVIOUS_COMMIT"
          
          echo ""
          echo "ðŸ“¥ Step 1: Pulling latest changes..."
          git fetch origin master
          git reset --hard origin/master
          NEW_COMMIT=$(git rev-parse HEAD)
          echo "âœ… Updated to commit: $NEW_COMMIT"
          
          echo ""
          echo "ðŸ“¦ Step 2: Installing dependencies..."
          /home/appadmin/.bun/bin/bun install --frozen-lockfile
          echo "âœ… Dependencies installed"
          
          echo ""
          echo "ðŸ”¨ Step 3: Building API..."
          cd apps/api
          /home/appadmin/.bun/bin/bun run build
          cd ../..
          echo "âœ… API built"
          
          echo ""
          echo "ðŸ”¨ Step 4: Building Web..."
          cd apps/web
          /home/appadmin/.bun/bin/bun run build
          cd ../..
          echo "âœ… Web built"
          
          echo ""
          echo "ðŸ”„ Step 5: Performing rolling restart..."
          
          # PM2 reload does rolling restart (one instance at a time)
          # This ensures zero downtime as new instances start before old ones stop
          pm2 reload ecosystem.config.cjs --update-env
          
          echo ""
          echo "â³ Step 6: Waiting for applications to stabilize..."
          sleep 10
          
          # Check if processes are running
          echo ""
          echo "ðŸ“Š PM2 Status:"
          pm2 status
          
          # Verify processes are online
          API_STATUS=$(pm2 jlist | jq -r '.[] | select(.name == "convocation-api") | .pm2_env.status')
          WEB_STATUS=$(pm2 jlist | jq -r '.[] | select(.name == "convocation-web") | .pm2_env.status')
          
          if [ "$API_STATUS" != "online" ] || [ "$WEB_STATUS" != "online" ]; then
            echo "âŒ One or more services failed to start!"
            echo "API Status: $API_STATUS"
            echo "Web Status: $WEB_STATUS"
            exit 1
          fi
          
          echo ""
          echo "=========================================="
          echo "ðŸŽ‰ Deployment completed successfully!"
          echo "=========================================="

      - name: ðŸ¥ Health Check (with retries)
        id: health_check
        run: |
          echo "Waiting for services to be fully ready..."
          sleep 5
          
          MAX_RETRIES=5
          RETRY_DELAY=5
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check API health (localhost since we're on the server)
            API_HEALTH=$(curl -sf "http://localhost:3001/health" || echo "failed")
            
            # Check Web health
            WEB_HEALTH=$(curl -sf -o /dev/null -w "%{http_code}" "http://localhost:3000/" || echo "000")
            
            echo "API Health: $API_HEALTH"
            echo "Web Health: $WEB_HEALTH"
            
            if [ "$API_HEALTH" != "failed" ] && [ "$WEB_HEALTH" = "200" ]; then
              echo "âœ… All health checks passed!"
              exit 0
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          echo "âŒ Health checks failed after $MAX_RETRIES attempts"
          exit 1
        continue-on-error: ${{ github.event.inputs.force_deploy == 'true' }}

      - name: ðŸ”™ Rollback on Failure
        if: failure() && steps.deploy.outcome == 'success' && steps.health_check.outcome == 'failure' && github.event.inputs.force_deploy != 'true'
        run: |
          echo "ðŸ”™ Initiating rollback due to failed health checks..."
          
          set -e
          
          BACKUP_DIR=$(cat /tmp/last_backup_path 2>/dev/null || echo "")
          
          if [ -z "$BACKUP_DIR" ] || [ ! -d "$BACKUP_DIR" ]; then
            echo "âŒ No backup found for rollback!"
            exit 1
          fi
          
          echo "ðŸ”™ Rolling back to backup: $BACKUP_DIR"
          
          cd ${{ env.DEPLOY_PATH }}
          
          # Restore previous commit
          if [ -f "$BACKUP_DIR/commit_hash" ]; then
            PREV_COMMIT=$(cat "$BACKUP_DIR/commit_hash")
            echo "Resetting to commit: $PREV_COMMIT"
            git reset --hard "$PREV_COMMIT"
          fi
          
          # Restore built artifacts
          if [ -d "$BACKUP_DIR/api-dist" ]; then
            rm -rf apps/api/dist
            cp -r "$BACKUP_DIR/api-dist" apps/api/dist
          fi
          
          if [ -d "$BACKUP_DIR/web-next" ]; then
            rm -rf apps/web/.next
            cp -r "$BACKUP_DIR/web-next" apps/web/.next
          fi
          
          # Reload PM2 with rolled back code
          pm2 reload ecosystem.config.cjs --update-env
          
          echo "âœ… Rollback completed!"
          pm2 status

      - name: ðŸ”“ Release Deployment Lock
        if: always()
        run: |
          rm -f /tmp/deploy.lock
          echo "ðŸ”“ Deployment lock released"

      - name: ðŸ“ Deployment Summary
        if: success()
        run: |
          echo "## ðŸŽ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # JOB 3: NOTIFY ON FAILURE
  # ===========================================
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy]
    if: failure()
    
    steps:
      - name: ðŸš¨ Deployment Failed
        run: |
          echo "## âŒ Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
